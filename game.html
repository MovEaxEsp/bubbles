<!DOCTYPE html>
<html>
<body oncontextmenu='return false'>

<canvas id="myCanvas" width="500" height="500"
style="border:1px solid #d3d3d3;">
Your browser does not support the HTML5 canvas tag.</canvas>

<script>
// Set up the canvas
var c = document.getElementById("myCanvas");
c.width = screen.width;
c.height = screen.height;
c.addEventListener('mousedown', handleMouseDown, false);
c.addEventListener('mousemove', handleMouseMove, false);
var cRect = c.getBoundingClientRect();
var ctx = c.getContext("2d");

// CONSTANTS

// FUNCTIONS
function getParameterByName(name, url) {
    if (!url) url = window.location.href;
    name = name.replace(/[\[\]]/g, "\\$&");
    var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
        results = regex.exec(url);
    if (!results) return null;
    if (!results[2]) return '';
    return decodeURIComponent(results[2].replace(/\+/g, " "));
}
var player = getParameterByName("player");

// Globals
var numCircles = 1;
var circles = [];
var isFullScreen = false;
var Sounds = {
    pop: [ "pop1.wav", "pop2.wav" ],
};

var Backgrounds = ["busytown", "clifford",
                  "jake", "paw-patrol", "thomas",
                  "wonder-woman", "frozen", "my-little-pony", "hulk",
                  "brave"];

var Bubbles = [ "bubble1.png", "bubble2.png" ];

if (player == "mia") {
    var SPEED=30;
    var MIN_BUBBLE_RADIUS = 50;
    var MAX_BUBBLE_RADIUS = 100;
    Sounds.yay = ["allHurray.wav", "kimMia.wav", "krysMia.wav",
                  "pawWooHoo.wav"]
}
else {
    var SPEED=0;
    var MIN_BUBBLE_RADIUS = 150;
    var MAX_BUBBLE_RADIUS = 200;
    Sounds.yay = ["allHurray.wav", "emiDidIt.wav", "kimEmi.wav", "miaEmi.wav",
                  "pawWooHoo.wav"]
}


// Replace each sound name with an Audio object for it
for (var key in Sounds) {
    for (var idx in Sounds[key]) {
        Sounds[key][idx] = new Audio("sounds/" + Sounds[key][idx]);
    }
}

// Replace each Background name with an object
// {
//   image: Image,
//   music: Audio
// }
for (var key in Backgrounds) {
    var img = new Image();
    img.src = "backgrounds/" + Backgrounds[key] + ".jpg";
    Backgrounds[key] = {
        image: img,
        music: new Audio("music/" + Backgrounds[key] + ".mp3")
    };
}

// Replace each Bubbles name with an Image object
for (var key in Bubbles) {
    var img = new Image();
    img.src = "images/" + Bubbles[key];
    Bubbles[key] = img;
}

// Add a function on arrays to pick a random element from the array.
Array.prototype.random = function(current) {
    var newVal = current;
    while (newVal === current) {
        var idx = Math.round((Math.random() * this.length) - .5);
        if (idx < 0) {
            idx = 0;
        }
        else if (idx >= this.length) {
            idx = this.length - 1;
        }
        newVal = this[idx];
    }
    return newVal;
};

var curBackground;

function changeBackground() {
    if (curBackground) {
        curBackground.music.pause();
    }

    curBackground = Backgrounds.random(curBackground);
    curBackground.music.currentTime = 0;
    curBackground.music.play();
}
changeBackground();

// Create a circle at the specified 'x' and 'y' coordinates, or at random
// coordinates if 'x' and 'y' aren't specified.
function createCircle(x, y) {
    var ret =  {
        x: x || Math.random() * cRect.width,
        y: y || Math.random() * cRect.height,
        radius: Math.random() * (MAX_BUBBLE_RADIUS - MIN_BUBBLE_RADIUS) +
                                                             MIN_BUBBLE_RADIUS,
        speedX: SPEED * Math.random(),
        speedY: SPEED * Math.random(),
        image: Bubbles.random(-1),
    };

    return ret;
}

// Advance the position of the specified 'circ' after the specified 'elapsed'
// time has passed.
function advanceCircle(circ, elapsed) {
    circ.x += circ.speedX * elapsed;
    circ.y += circ.speedY * elapsed;

    if (circ.x > cRect.width) {
        circ.x = 0;
    }

    if (circ.y >= cRect.height) {
        circ.y = 0;
    }

    if (circ.x < 0) {
        circ.x = cRect.width;
    }

    if (circ.y < 0) {
        circ.y = cRect.height;
    }
}

// Draw the specified 'circ'.
function drawCircle(circ) {

    // We want to make the bubble appear on all 4 edges if necessary, if
    // it's too close to the edge
    var xOffsets = [0];
    if (circ.x + circ.radius > cRect.width) {
        xOffsets.push(-cRect.width);
    }
    else if (circ.x - circ.radius < 0) {
        xOffsets.push(cRect.width);
    }

    var yOffsets = [0]
    if (circ.y + circ.radius > cRect.height) {
        yOffsets.push(-cRect.height);
    }
    else if (circ.y - circ.radius < 0) {
        yOffsets.push(cRect.height);
    }

    for (var xIdx = 0; xIdx < xOffsets.length; ++xIdx) {
        for (var yIdx = 0; yIdx < yOffsets.length; ++yIdx) {
            ctx.drawImage(circ.image,
                          circ.x - circ.radius + xOffsets[xIdx],
                          circ.y - circ.radius + yOffsets[yIdx],
                          2 *circ.radius,
                          2 *circ.radius);
        }
    }
}

function handleMouseDown(event) {
    var x = event.clientX - cRect.left;
    var y = event.clientY - cRect.top;

    if (!isFullScreen) {
        c.webkitRequestFullScreen();

        // Getting the bounding client rect immediately after requesting
        // full-screen doesn't seem to give the right value.
        setTimeout(function() { cRect = c.getBoundingClientRect(); }, 100);
    }

    if (event.button ===  0) {
        bubbleHit(x, y);
    }
    else if (event.button === 2) {
        bubbleHit(x, y);
        //canvasRightClicked(x, y);
    }
}

function handleMouseMove(event) {
    var x = event.clientX - cRect.left;
    var y = event.clientY - cRect.top;

    //bubbleHit(x, y);
}

// Play one of the specified 'sounds'
function playSound(sounds) {
    var sound = sounds.random(-1);
    sound.currentTime = 0;
    sound.play();
}

// Return 'true' if the specified 'circ' is hit by a click at the specified
// 'x' and 'y' coordinates.
function checkHit(circ, x, y) {
    var xOffsets = [0];
    if (circ.x + circ.radius > cRect.width) {
        xOffsets.push(-cRect.width);
    }
    else if (circ.x - circ.radius < 0) {
        xOffsets.push(cRect.width);
    }

    var yOffsets = [0]
    if (circ.y + circ.radius > cRect.height) {
        yOffsets.push(-cRect.height);
    }
    else if (circ.y - circ.radius < 0) {
        yOffsets.push(cRect.height);
    }

    for (var xIdx = 0; xIdx < xOffsets.length; ++xIdx) {
        for (var yIdx = 0; yIdx < yOffsets.length; ++yIdx) {
            var xDiff = circ.x - x + xOffsets[xIdx];
            var yDiff = circ.y - y + yOffsets[yIdx];
            var distance = Math.sqrt((xDiff * xDiff) + (yDiff * yDiff));
            if (distance <= circ.radius) {
                return true;
            }
        }
    }

    return false;
}

// Handle an attempt to hit a bubble at the specified 'x' and 'y' coordinates
function bubbleHit(x, y) {
    for (var circIdx in circles) {
        var circ = circles[circIdx];
        if (checkHit(circ, x, y)) {
            // Remove circles until none are left, then create them all again,
            // plus 1 extra
            circles.splice(circIdx, 1);
            playSound(Sounds.pop);
            break;
        }
    }

    if (circles.length === 0) {
        numCircles++;
        for (var i = 0; i < numCircles; ++i) {
            circles.push(createCircle());
        }

        changeBackground();

        // Play a yay :)
        setTimeout(function() { playSound(Sounds.yay); }, 500);
    }
}

function canvasRightClicked(x, y) {
    //circles.push(createCircle(x, y));
}

// Update our state/draw our frame.  Assume we're called 60 times/sec
function draw() {
    var elapsed = 1.0/60;

    // Draw background
    ctx.drawImage(curBackground.image, 0, 0, cRect.width, cRect.height);

    // Draw circles
    for (var i = 0; i < circles.length; ++i) {
        var circ = circles[i];
        advanceCircle(circ, elapsed);
        drawCircle(circ);
    }
}

// Create initial circles
for (var i = 0; i < numCircles; ++i ) {
    circles.push(createCircle());
}

// Set up our draw function to be called 60 times/sec
setInterval(draw, 1000/60);
//setInterval(draw, 2000);

</script>

</body>
</html>
